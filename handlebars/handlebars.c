///////////////////////////////////////////////////////////////////////////////
// NAME:            handlebars.c
//
// AUTHOR:          Ethan D. Twardy <ethan.twardy@gmail.com>
//
// DESCRIPTION:     Parser entrypoint
//
// CREATED:         11/20/2021
//
// LAST EDITED:     12/18/2021
//
// Copyright 2021, Ethan D. Twardy
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
////

#include <assert.h>
#include <stdbool.h>
#include <stdlib.h>

#include <handlebars/handlebars.h>
#include <handlebars/nary-tree.h>
#include <handlebars/vector.h>

// This struct contains context necessary to parse the template and render it
// using context.
// TODO: Could probably remove input_context/top, wrap these in a different
// struct and pass that around in yycontext instead of a Handlebars*
typedef struct Handlebars {
    HbInputContext* input_context;
    HbNaryTree* components;
    HbNaryNode* top;
} Handlebars;

// Events generated by the LR parser
enum HbEventType {
    HB_TEXT,
    HB_OPEN_BARS,
    HB_CLOSE_BARS,
    HB_EXPRESSION,
};

// Component types handled so far:
enum HbComponentType {
    HB_COMPONENT_TEXT, // A simple block of text
    HB_COMPONENT_EXPR, // An expression. Could be context subst. or helper
};

// Components that provide the parts necessary to render a template.
typedef struct HbComponent {
    enum HbComponentType type;
    union {
        HbString* string;
        HbVector* arguments;
    };
} HbComponent;

// This is all to set up the LR parser, generated using peg(1).
static void hb_event(Handlebars* handlebars, enum HbEventType event,
    const char* content);
typedef struct _yycontext yycontext;
static void hb_priv_input(yycontext* context, char* buffer, int* result,
    int max_size);
#define YY_CTX_LOCAL 1
#define YY_INPUT(context, buffer, result, max_size)     \
    hb_priv_input(context, buffer, &result, max_size);
#define YY_CTX_MEMBERS Handlebars* handlebars;
#pragma GCC diagnostic ignored "-Wunused-parameter"
#pragma GCC diagnostic ignored "-Wunused-function"
#include "parser.c"
#pragma GCC diagnostic pop
#pragma GCC diagnostic pop

///////////////////////////////////////////////////////////////////////////////
// Private API
////

// Free a component
static void hb_priv_free_component(void* element_data) {
    HbComponent* component = (HbComponent*)element_data;
    if (HB_COMPONENT_TEXT == component->type) {
        hb_string_free(&component->string);
    }
    else if (HB_COMPONENT_EXPR == component->type) {
        for (size_t i = 0; i < component->arguments->length; ++i) {
            hb_string_free((HbString**)&(component->arguments->vector[i]));
        }
        hb_vector_free(&component->arguments, NULL);
    }
    free(component);
}

// Callback from the LR parser, which adds a new component to the AST. This
// function handles all kinds of events.
static void hb_event(Handlebars* handlebars, enum HbEventType event,
    const char* content)
{
    if (HB_TEXT == event) {
        HbComponent* component = malloc(sizeof(HbComponent));
        assert(NULL != component);
        component->type = HB_COMPONENT_TEXT;
        component->string = hb_string_from_str(content);
        HbNaryNode* node = hb_nary_node_new(component, hb_priv_free_component);
        hb_nary_node_append_child(handlebars->components, handlebars->top,
            node);
    } else if (HB_OPEN_BARS == event) {
        HbComponent* component = malloc(sizeof(HbComponent));
        assert(NULL != component);
        component->type = HB_COMPONENT_EXPR;
        component->arguments = hb_vector_init();
        HbNaryNode* node = hb_nary_node_new(component, hb_priv_free_component);
        hb_nary_node_append_child(handlebars->components, handlebars->top,
            node);
        handlebars->top = node;
    } else if (HB_CLOSE_BARS == event) {
        handlebars->top = hb_nary_node_get_parent(handlebars->top);
    } else if (HB_EXPRESSION == event) {
        HbComponent* component = (HbComponent*)hb_nary_node_get_data(
            handlebars->top);
        HbString* argument = hb_string_from_str(content);
        hb_vector_push_back(component->arguments, argument);
    } else {
        assert(0); // Programmer's error.
    }

    /* if (HB_OPEN_BARS != event && HB_CLOSE_BARS != event) { */
    /*     printf("%d: \"%s\"\n", event, content); */
    /* } else { */
    /*     printf("%d\n", event); */
    /* } */
}

// Invoke the HbInputContext to fill the parser buffer
void hb_priv_input(yycontext* context, char* buffer, int* result,
    int max_size)
{
    Handlebars* handlebars = context->handlebars;
    HbInputContext* input_context = handlebars->input_context;
    assert(NULL != input_context);

    int bytes_copied = input_context->read(input_context->data, buffer,
        max_size);
    *result = bytes_copied;
}

///////////////////////////////////////////////////////////////////////////////
// Public API
////

// Load a template in from the input_context. If the input_context is backed by
// a file, this function will construct the template components from the
// contents of that file as it is on disk currently. The template is not
// reloaded every time the template is rendered (unless explicitly done so).
Handlebars* handlebars_template_load(HbInputContext* input_context) {
    Handlebars* template = malloc(sizeof(Handlebars));
    if (NULL == template) {
        return NULL;
    }

    template->input_context = input_context;
    yycontext context;
    memset(&context, 0, sizeof(yycontext));
    context.handlebars = template;
    template->components = hb_nary_tree_new();
    HbNaryNode* root = hb_nary_node_new(NULL, NULL);
    hb_nary_node_append_child(template->components, NULL, root);
    template->top = root;

    while (yyparse(&context));

    yyrelease(&context);
    template->input_context = NULL;
    return template;
}

// Render the template using the template context. The input context contains
// all context data and helpers (with the exception of the default helpers). If
// the template contains expressions which don't match up to entries in the
// context, those expressions are rendered as the empty string "".
HbString* handlebars_template_render(Handlebars* template,
    HbTemplateContext* context)
{
    HbString* result = hb_string_init();
    HbNaryNodeIter iterator;
    hb_nary_node_iter_init(&iterator, template->components);
    HbNaryNode* element = NULL;
    HbComponent* component = NULL;
    while (NULL != (element = hb_nary_node_iter_next(&iterator)) &&
        NULL != (component = (HbComponent*)hb_nary_node_get_data(element))) {
        switch (component->type) {
        case HB_COMPONENT_TEXT:
            if (0 != hb_string_append(result, component->string)) {
                hb_string_free(&result);
                return NULL;
            }
            break;
        case HB_COMPONENT_EXPR: {
            // Simple expression: Just substitute from context.
            if (1 == component->arguments->length) {
                const HbString* value = handlebars_template_context_get(
                    context, (HbString*)component->arguments->vector[0]);
                if (NULL == value) {
                    break;
                }
                hb_string_append(result, value);
            }
            break;
        }
        default:
            hb_string_free(&result);
            assert(false);
        }
    }

    return result;
}

// Free the template components, relinquishing all allocated memory back to the
// system.
void handlebars_template_free(Handlebars** template) {
    if (NULL != *template) {
        if (NULL != (*template)->components) {
            hb_nary_tree_free(&(*template)->components);
        }

        free(*template);
        *template = NULL;
    }
}

///////////////////////////////////////////////////////////////////////////////
